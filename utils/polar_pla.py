import PiecewiseLinearSegmentation
import matplotlib.pyplot as plt
import numpy as np
import math
import statistics
from numpy.lib.function_base import average
from matplotlib.lines import Line2D
from matplotlib.pylab import gca, figure, plot, subplot, title, xlabel, ylabel, xlim,show
import utils.segment as segment
import utils.fit as fit

def median_filter(time_series, filter_size):
    '''
    This method applies median filtering to a time series to remove noise
    '''
    result = []

    for i in range(len(time_series)):
        if((i < (filter_size-1)/2) or i>(len(time_series))-(filter_size-1)/2 - 1):
            result.append(time_series[i])

        else:
            temp = []
            for pos in range(filter_size):
                temp.append(time_series[i - filter_size//2 + pos])
            
            temp.sort()
            med = temp[len(temp)//2]
            result.append(med)
    plt.plot(result)
    plt.show()
    return result



def bottom_up_pla(time_series, max_error):

    x = PiecewiseLinearSegmentation.Bottomup(max_error=max_error)
    output = []
    trendX, trendY = [], []
    for trend in x.transform(time_series):
        # first we need the angle of inclination. We will normalize this to a value from -1 to 1 (-90 degrees to 90 degrees)
        # each trend has the structure [startX, startY, endX, endY], however this doesn't lend itself well to ML since 
        # incorrect x prediction values can go backwards.
        startX, startY, endX, endY = trend[0], trend[1], trend[2], trend[3]
        trendX.append(trend[0])
        trendY.append(trend[1])
        trendX.append(trend[2])
        trendY.append(trend[3])

        angle = math.degrees(math.atan((endY - startY)/(endX - startX)))
        # now we need to normalize the angle to a value from -1 to 1
        angle /= 90
        
        # now we need to calculate the length of the trend
        length = trend[2]-trend[0]#np.sqrt((endX - startX)**2 + (endY - startY)**2)
        output.append(angle)
        output.append(length)

    max_length = max(output)
    #print("MAX LENGTH:"+str(max_length))
    w = open('trends.csv','w')
    for i in range(0,len(output),2):
        w.write(str(output[i])+","+str(output[i+1]/max_length)+"\n")
    for val in range(1,len(output),2):
        output[val] = output[val]/max_length
    plt.plot(trendX,trendY)
    plt.show()
    return output, max_length

def sliding_window_pla(time_series, max_error):

    x = sliding_window(time_series, max_error)#PiecewiseLinearSegmentation.Sliding(max_error=max_error)
    output = []
    trendX, trendY = [], []
    for trend in x:#.transform(time_series):
        # first we need the angle of inclination. We will normalize this to a value from -1 to 1 (-90 degrees to 90 degrees)
        # each trend has the structure [startX, startY, endX, endY], however this doesn't lend itself well to ML since 
        # incorrect x prediction values can go backwards.
        startX, startY, endX, endY = trend[0], trend[1], trend[2], trend[3]
        trendX.append(trend[0])
        trendY.append(trend[1])
        trendX.append(trend[2])
        trendY.append(trend[3])

        angle = math.degrees(math.atan((endY - startY)/(endX - startX)))
        # now we need to normalize the angle to a value from -1 to 1
        angle /= 90
        
        # now we need to calculate the length of the trend
        length = trend[2]-trend[0]#np.sqrt((endX - startX)**2 + (endY - startY)**2)
        output.append(angle)
        output.append(length)

    max_length = max(output)
    #print("MAX LENGTH:"+str(max_length))
    w = open('trends.csv','w')
    for i in range(0,len(output),2):
        w.write(str(output[i])+","+str(output[i+1]/max_length)+"\n")
    for val in range(1,len(output),2):
        output[val] = output[val]/max_length
    plt.plot(trendX,trendY, color='orange')
    plt.show()
    return output, max_length

def display_trends(trends, startY):
    # this function will reconstruct a graph using the trends generated by the bottom_up_pla function
    # it will also display the graph
    X = [0]
    Y = [startY]
    for i in range(0,len(trends),2):
        #print(trends[i])
        X.append(X[int(i/2)]+(trends[i+1])*np.cos(np.deg2rad(trends[i]*90)))
        #print(X[i-1]+(trends[i][1]*10)/np.cos(np.deg2rad(trends[i][0])))
        Y.append(Y[int(i/2)]+(trends[i+1])*np.sin(np.deg2rad(trends[i]*90)))
        #print(Y[i-1]+(trends[i][1])*np.sin(np.deg2rad(trends[i][0])))
    plt.plot(X,Y)
    #plt.show()

def bottom_up(time_series, max_error, minimum_trend_length):

    # okay whoever wrote that PLS library your code is booboo
    # let me show you how it's done
    trends = []
    for i in range(len(time_series)-1):
        # make lots of little trends
        trends.append((time_series[i], time_series[i+1]))
    
    max_error = 100
    windowsize = 3 # think of this as the number of elements in our window
    i = 0
    m = math.mean(time_series[i:i+windowsize])
    window_var = (time_series[0]-m)**2
    window_var += (time_series[1]-m)**2
    window_var += (time_series[2]-m)**2
    window_var /= 2

    # now we have the variance of a basic window
    # now keep growing the window until we exceed the max error
    while(window_var < max_error):
        # ref: https://math.stackexchange.com/questions/102978/incremental-computation-of-standard-deviation
        # now we need to grow the window and adjust the variance using this handy equation
        windowsize += 1
        window_var = (windowsize-2)/(windowsize-1) * window_var + (1/(windowsize))*(time_series[windowsize-1]-m)**2
        m = (m*(windowsize-1)+time_series[windowsize])/windowsize


def sliding_window(time_series, max_error):
    anchor = 0
    trends = []
    window_size = 3
    # initial calculation 
    data = time_series[0:window_size]
    E_x = (window_size+1)/2
    E_y = average(data)
    E_y2= average(np.square(data))
    yes = []
    for fish in range(len(data)):
        yes.append(data[fish]*(fish+1))
    E_xy = (sum(yes))/window_size
    E_x2 = average(np.square(range(1,window_size+1)))
    m = (E_x*E_y-E_xy)/(E_x**2-E_x2)
    b = E_y-m*E_x
    loss = E_y2 - 2 * (m * E_xy + b * E_y) + m**2 * E_x2 + 2 * m * b * E_x + b**2

    # now expand the window size
    while anchor + window_size + 1 < len(time_series):
        while loss*window_size < max_error and anchor + window_size + 1 < len(time_series):
            window_size+=1
            N = window_size-1
            new_x = window_size
            new_y = time_series[anchor+window_size]
            E_x = E_x*N/(N+1) + new_x*1/(N+1)
            E_y = E_y*N/(N+1) + new_y*1/(N+1)
            E_xy = E_xy*N/(N+1) + new_x*new_y*1/(N+1)
            E_x2 = E_x2*N/(N+1) + new_x*new_x*1/(N+1)
            E_y2 = E_y2*N/(N+1) + new_y*new_y*1/(N+1)
            m = (E_x*E_y-E_xy)/(E_x**2-E_x2)
            b = E_y-m*E_x
            loss = E_y2 - 2 * (m * E_xy + b * E_y) + m**2 * E_x2 + 2 * m * b * E_x + b**2
        #print("trend added m:"+str(m)+" b:"+str(b)+" window size = "+str(window_size))
        trends.append([anchor, b+m, anchor+window_size-1, b+m*(window_size)])
        anchor += window_size-1
        window_size = 3
        if anchor + window_size + 1 < len(time_series):
            data = time_series[anchor:anchor+window_size]
            E_x = (window_size+1)/2
            E_y = average(data)
            E_y2= average(np.square(data))
            yes = []
            for fish in range(len(data)):
                yes.append(data[fish]*(fish+1))
            E_xy = (sum(yes))/window_size
            E_x2 = average(np.square(range(1,window_size+1)))
            m = (E_x*E_y-E_xy)/(E_x**2-E_x2)
            b = E_y-m*E_x
            loss = E_y2 - 2 * (m * E_xy + b * E_y) + m**2 * E_x2 + 2 * m * b * E_x + b**2

    #trends.append([anchor, b, anchor+window_size, (time_series[anchor]+b+(window_size)*m)])
    return trends

def topdown_interpolated(time_series, max_error):

    figure()
    segments = segment.topdownsegment(time_series, fit.interpolate, fit.sumsquared_error_int, max_error)
    draw_plot(time_series,"Top-down with simple interpolation")
    draw_segments(segments)

def draw_plot(data,plot_title):
    plot(range(len(data)),data,alpha=0.8,color='red')
    title(plot_title)
    xlabel("Samples")
    ylabel("Signal")
    xlim((0,len(data)-1))

def draw_segments(segments):
    ax = gca()
    for segment in segments:
        line = Line2D((segment[0],segment[2]),(segment[1],segment[3]))
        ax.add_line(line)

def preprocess(file_name, filter_size, pls_max_error):
    '''
        Performs all data preprocessing steps and returns a processed trend series
    '''
    # read in the time series
    f = open(file_name, 'r')
    time_series = []
    for line in f:
        time_series.append(float(line))
    
    # plot the time series in purple
    plt.plot(time_series, color='orange')
    plt.show()

    # apply median filter
    time_series = median_filter(time_series, filter_size)

    # apply sliding window piecewise linear segmentation
    x, _ = sliding_window_pla(time_series, pls_max_error)
    return x


if __name__ == "__main__":
    f = open('DataSets/CTtemp.csv')
    data = f.readlines()[0:1000]
    f.close()
    ts = []
    for line in data:
        ts.append(float(line))
    #plt.plot(ts)
    ts = median_filter(ts)
    sliding_window_pla(ts)
    #topdown_interpolated(ts,1000)
    #trends = sliding_window(ts, 1000)
    #for t in trends:
    #    plt.plot([t[0],t[2]],[t[1],t[3]], color='orange')
    #plt.show()
